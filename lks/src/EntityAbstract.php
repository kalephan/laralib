<?php

namespace Kalephan\LKS;

use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Request;
use Illuminate\Support\Facades\Session;

abstract class EntityAbstract
{

    private $structure;

    private $model;

    private $cache_name;

    abstract public function __structure($structure);

    public function __construct()
    {
        $this->cache_name = lks_cache_name(__CLASS__ . '-entity') . '-@id-@entity';
        $this->structure = $this->structure();
        $this->model = new $this->structure->model();
    }

    public function structure()
    {
        if (! $this->structure) {
            $this->structureSet();
        }

        return $this->structure;
    }

    private function structureSet()
    {
        $cache_prefix = lks_cache_name(__METHOD__);
        $cache_name = $cache_prefix . get_called_class();

        if (! $this->structure = Cache::get($cache_name)) {
            $this->structureInit();
            $this->__structure($this->structure);

            event('lks.entityStructureAlter', $this->structure);
            event('lks.entityStructureAlter: ' . $this->structure->class, $this->structure);

            $this->structureValidate();

            Cache::forever($cache_name, $this->structure);
        }
    }

    private function structureInit()
    {
        $this->structure = new \stdClass();

        $this->structure->class = get_called_class();
        $this->structure->model = $this->structure->class . 'Model';
        $this->structure->title = '';
        $this->structure->id = 'id';
        $this->structure->fields = [];
        $this->structure->indelibility = [];
        $this->structure->order_by = ['id' => 'desc'];
        $this->structure->url_prefix = '';
        $this->structure->actions = [
            'view' => ['url' => '@structure_url_prefix/@id', 'title' => lks_lang('Xem')],
            'edit' => ['url' => '@structure_url_prefix/@id/edit', 'title' => lks_lang('Sửa')],
            'delete' => ['url' => '@structure_url_prefix/@id/delete', 'title' => lks_lang('Xóa')],
        ];
    }

    private function structureValidate()
    {
        foreach ($this->structure->fields as $key => $value) {
            $this->structure->fields[$key]['#name'] = empty($value['#name']) ? $key : $value['#name'];
            $this->structure->fields[$key]['#title'] = empty($value['#title']) ? $this->structure->fields[$key]['#name'] : $value['#title'];
        }
    }

    public function saveEntity($entity_new, $active_action = false)
    {
        $entity = ! empty($entity_new->{$this->structure->id}) ? $this->model->find($entity_new->{$this->structure->id}) : null;

        // Update an entity
        if (! empty($entity->{$this->structure->id})) {
            // Delete cache was generated by loadEntity
            Cache::forget(str_replace([
                '@id',
                '@entity'
            ], [
                $entity->{$this->structure->id},
                $this->structure->class
            ], $this->cache_name));
        }         // Create a new entity
        else {
            $entity = $this->model;
        }

        $this->saveEntityBuildData($entity, $entity_new);
        $entity->save();

        // Save reference fields from temp to database
        /*
         * if (count($reference)) {
         * $this->saveEntityReference($reference, $entity->{$this->structure->id});
         * }
         */

        event('lks.entitySaveEntity', $entity);
        event('lks.entitySaveEntity: ' . $this->structure->class, $entity);

        return $entity->{$this->structure->id};
    }

    private function saveEntityBuildData($entity, $entity_new)
    {
        foreach ($this->structure->fields as $key => $field) {
            switch ($key) {
                case 'created_by':
                    if (! empty($entity_new->created_by)) {
                        break;
                    }
                case 'updated_by':
                    if (Auth::id() && ! $active_action) {
                        $entity[$key] = Auth::id();
                    }
                    break;

                default:
                    if (isset($entity_new->{$key}) &&
                    // this field is not empty
                    (! empty($entity_new->{$key}) ||
                    // OR this field is not require
                    empty($field['#required']))) {
                        $entity->{$key} = $entity_new->{$key};
                    }                    // Save default value for new entity create
                    elseif (isset($field['#default']) && empty($entity_new->{$this->structure->id})) {
                        $entity->{$key} = $field['#default'];
                    }
            }
        }

        event('lks.entitySaveEntityBuildData', $entity);
        event('lks.entitySaveEntityBuildData: ' . $this->structure->class, $entity);

        // Update waiting approve
        /*
         * if (!empty($this->structure['#approve'])// Use approve feature
         * && isset($this->structure->fields['approve'])// Have approve field
         * && !empty($entity_new->{$this->structure->id})//Not create new
         * ) {
         * $entity_approve_obj = lks_instance_get()->load('\Kalephan\LKS\Approve\ApproveEntity');
         *
         * if ($approve) {
         * $entity_approve_obj->deleteEntity($entity->approve);
         *
         * $entity->approve = null;
         * } else {
         * $approve_name = $this->structure->class . '-' . $entity_new->{$this->structure->id};
         *
         * //$entity->{$this->structure->id} = $entity_old->{$this->structure->id};
         * $entity->approve = $approve_name;
         *
         * $entity_approve = new \stdClass;
         * $entity_approve->key = $approve_name;
         * $entity_approve->value = $entity;
         * $entity_approve_obj->saveEntity($entity_approve);
         *
         * $entity = new \stdClass;
         * $entity->{$this->structure->id} = $entity_new->{$this->structure->id};
         * $entity->approve = $approve_name;
         * }
         * }
         */

        // Build reference
        /*
         * $reference = [];
         * foreach ($this->structure->fields as $key => $field) {
         * // Save Reference fields to temp
         * if (isset($field['#reference'])
         * && isset($entity->{$field['#name']})
         * && isset($field['#reference']['internal'])
         * && !$field['#reference']['internal']
         * ) {
         * $reference[$field['#name']] = is_array($entity->{$field['#name']}) ? array_filter($entity->{$field['#name']}) : [];
         * unset($entity->{$field['#name']});
         * }
         * }
         */
    }

    /*
     * private function _updateEntity($entity_new, $entity_old) {
     * foreach ($entity_new as $key => $value) {
     * $entity_old->$key = $value;
     * }
     * $entity_old->save();
     * }
     */

    /*
     * public function saveEntityReference($reference, $entity_id) {
     * $this->model->saveReference($reference, $entity_id, $this->structure);
     * }
     */
    public function convertEntityId($entity_id)
    {
        switch ($entity_id) {
            case 'me':
                if ($user_id = Auth::id()) {
                    return $user_id;
                }
                App::abort(403);

            case 'sess':
                return Session::getId();

            default:
                return $entity_id;
        }
    }

    public function loadEntity($entity_id, $check_active = false)
    {
        $entity_id = $this->convertEntityId($entity_id);

        $cache_name = str_replace(['@id', '@entity'], [$entity_id, $this->structure->class], $this->cache_name);
        if ($cache = Cache::get($cache_name)) {
            if (! $check_active) {
                return $cache;
            } elseif (! isset($this->structure->fields['active']) || $cache->active == 1) {
                return $cache;
            } else {
                return null;
            }
        }

        if ($entity = $this->model->find($entity_id)) {
            foreach ($this->structure->fields as $key => $field) {
                if (isset($field['#reference']) && $entity->$key) {
                    $reference = new $field['#reference']['class'];
                    $entity->$key = $reference->loadEntity($entity->$key);
                }
            }

            event('lks.entityLoadEntity', $entity);
            event('lks.entityLoadEntity: ' . $this->structure->class, $entity);

            Cache::forever($cache_name, $entity);
        }

        return $entity;
    }

    public function loadEntityWhere($where)
    {
        $model = $this->model->select($this->structure->id);

        foreach ($where as $value) {
            if (count($value) == 3) {
                $model = $model->where($value[0], $value[1], $value[2]);
            }
        }

        return $this->_loadEntityAll($model->get());
    }

    public function loadEntityPaginate($items_per_page = null)
    {
        $items_per_page = $items_per_page ? $items_per_page : config('lks.items_per_page', 20);

        $db = $this->model->select($this->structure->id);
        if (count($this->structure->order_by)) {
            foreach ($this->structure->order_by as $key => $value) {
                $db->orderBy($key, $value);
            }
        }

        $paginator = $db->paginate($items_per_page);
        $paginator->appends(Request::except('page'));

        return [
            'paginator' => $paginator,
            'entities' => $this->_loadEntityAll($paginator->all())
        ];
    }

    public function loadEntityAll()
    {
        $entities = $this->model->select($this->structure->id)->all();

        return $this->_loadEntityAll($entities);
    }

    private function _loadEntityAll($entities)
    {
        foreach ($entities as $key => $value) {
            $entities[$key] = $this->loadEntity($value->{$this->structure->id});
        }

        return $entities;
    }

    /*
     * public function loadEntityAll($attr = []) {
     * // Get from cache
     * if (!isset($attr['cache']) || $attr['cache']) {
     * $cache_name = lks_cache_name(__METHOD__) . '-' . $this->structure->class . '-' . serialize($attr);
     *
     * if ($cache_content = Cache::get($cache_name)) {
     * return $cache_content;
     * }
     * }
     *
     * // Get from database
     * $entity = $this->model->loadEntityAll($this->structure, $attr);
     *
     * // Set to cache
     * if (!isset($attr['cache']) || $attr['cache']) {
     * lks_cache_set($cache_name, $entity);
     * }
     *
     * return $entity;
     * }
     */

    /*
     * public function loadEntityWhere($attr = []) {
     * // Get from cache
     * if (!isset($attr['cache']) || $attr['cache']) {
     * $cache_name = lks_cache_name(__METHOD__) . '-' . $this->structure->class . '-' . serialize($attr);
     *
     * if ($cache_content = Cache::get($cache_name)) {
     * return $cache_content;
     * }
     * }
     *
     * // Get from database
     * $entity = $this->model->loadEntity($this->structure, $attr);
     * if ($entity) {
     * $entity = $this->buildEntity($entity, $attr);
     * }
     *
     * // Set to cache
     * if (!isset($attr['cache']) || $attr['cache']) {
     * lks_cache_set($cache_name, $entity);
     * }
     *
     * return $entity;
     * }
     */
    public function deleteEntity($entity_ids)
    {
        $entity_ids = (array) $entity_ids;

        if ($this->structure->indelibility) {
            $entity_ids = array_diff($entity_ids, $this->structure->indelibility);
        }

        if (count($entity_ids)) {
            foreach ($entity_ids as $value) {
                Cache::forget(str_replace([
                    '@id',
                    '@entity'
                ], [
                    $value,
                    $this->structure->class
                ], $this->cache_name));
            }

            $this->model->destroy($entity_ids);
        }
    }

    public function isOwn($entity)
    {
        if (! is_object($entity)) {
            $entity = $this->loadEntity($entity);
        }

        if (isset($entity->created_by) && $entity->created_by == Auth::id()) {
            return true;
        }

        return false;
    }
}